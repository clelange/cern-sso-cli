package cookie

import (
	"bufio"
	"fmt"
	"net/http"
	"net/http/cookiejar"
	"net/url"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"golang.org/x/net/publicsuffix"
)

// MatchDomain checks if a cookie domain matches the target domain.
// Cookie domain ".example.com" matches "sub.example.com" and "example.com".
// Cookie domain "example.com" matches only "example.com".
func MatchDomain(cookieDomain, targetDomain string) bool {
	if cookieDomain == "" {
		return false
	}
	// Exact match
	if cookieDomain == targetDomain {
		return true
	}
	// Leading dot means subdomains match
	if strings.HasPrefix(cookieDomain, ".") {
		// ".example.com" matches "sub.example.com" and "example.com"
		base := strings.TrimPrefix(cookieDomain, ".")
		if targetDomain == base || strings.HasSuffix(targetDomain, cookieDomain) {
			return true
		}
	}
	return false
}

// FilterAuthCookies returns cookies that belong to the auth hostname.
func FilterAuthCookies(cookies []*http.Cookie, authHost string) []*http.Cookie {
	var authCookies []*http.Cookie
	for _, c := range cookies {
		if c.Domain == authHost || c.Domain == "."+authHost || strings.HasSuffix(c.Domain, "."+authHost) {
			authCookies = append(authCookies, c)
		}
	}
	return authCookies
}

// VerifyCookies checks if cookies are valid for the target URL.
// Returns (valid, remainingDuration) tuple.
func VerifyCookies(targetURL, authHost string, cookies []*http.Cookie) (bool, time.Duration) {
	u, err := url.Parse(targetURL)
	if err != nil {
		return false, 0
	}

	jar, err := NewJar()
	if err != nil {
		return false, 0
	}

	// Set cookies via URLs matching their domains
	// This ensures the cookie jar properly associates cookies with their domains
	authURL := &url.URL{Scheme: "https", Host: authHost, Path: "/"}
	for _, c := range cookies {
		if c.Domain == authHost || c.Domain == "."+authHost || strings.HasSuffix(c.Domain, "."+authHost) {
			jar.SetCookies(authURL, []*http.Cookie{c})
		} else {
			jar.SetCookies(u, []*http.Cookie{c})
		}
	}

	client := &http.Client{
		Jar: jar,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			if req.URL.Host == authHost {
				return http.ErrUseLastResponse
			}
			return nil
		},
	}

	resp, err := client.Get(targetURL)
	if err != nil {
		return false, 0
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusOK && resp.Request.URL.Host != authHost {
		// Calculate minimum remaining validity
		var minDuration time.Duration = 100000 * time.Hour // Start large
		found := false
		now := time.Now()

		for _, c := range cookies {
			if c.Expires.IsZero() {
				continue
			}
			// Only consider cookies that haven't expired yet (though verify check implies they worked)
			if c.Expires.After(now) {
				d := c.Expires.Sub(now)
				if d < minDuration {
					minDuration = d
					found = true
				}
			}
		}
		if !found {
			minDuration = 0
		}
		return true, minDuration
	}
	return false, 0
}

// Jar wraps http.CookieJar with persistence to Netscape format.
type Jar struct {
	*cookiejar.Jar
}

// NewJar creates a new cookie jar.
func NewJar() (*Jar, error) {
	jar, err := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List})
	if err != nil {
		return nil, err
	}
	return &Jar{Jar: jar}, nil
}

// Save writes cookies to a file in Netscape format.
func (j *Jar) Save(filename string, cookies []*http.Cookie, domain string) error {
	dir := filepath.Dir(filename)
	if dir != "" {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}

	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()

	// Netscape cookie file header
	fmt.Fprintln(f, "# Netscape HTTP Cookie File")
	fmt.Fprintln(f, "# https://curl.se/docs/http-cookies.html")
	fmt.Fprintln(f, "# This file was generated by cern-sso-cli. Edit at your own risk.")
	fmt.Fprintln(f, "")

	for _, c := range cookies {
		httpOnly := "FALSE"
		if c.HttpOnly {
			httpOnly = "TRUE"
		}
		secure := "FALSE"
		if c.Secure {
			secure = "TRUE"
		}
		expires := c.Expires.Unix()
		if expires <= 0 {
			// Default to 10 hours from now if no expiry (CERN SSO cookie validity)
			expires = time.Now().Add(10 * time.Hour).Unix()
		}
		domainField := c.Domain
		if domainField == "" {
			domainField = domain
		}
		includeSubdomains := "FALSE"
		if strings.HasPrefix(domainField, ".") {
			includeSubdomains = "TRUE"
		}
		path := c.Path
		if path == "" {
			path = "/"
		}
		// Format: domain \t include_subdomains \t path \t secure \t expires \t name \t value
		// Note: httpOnly is encoded as #HttpOnly_ prefix on domain
		domainOutput := domainField
		if c.HttpOnly {
			domainOutput = "#HttpOnly_" + domainField
			httpOnly = "TRUE" // Not used in standard format, but we use prefix
		}
		_ = httpOnly // silence unused warning; httpOnly is encoded in domain prefix
		fmt.Fprintf(f, "%s\t%s\t%s\t%s\t%d\t%s\t%s\n",
			domainOutput, includeSubdomains, path, secure, expires, c.Name, c.Value)
	}

	return nil
}

// Load reads cookies from a Netscape format file.
func Load(filename string) ([]*http.Cookie, error) {
	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	var cookies []*http.Cookie
	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := scanner.Text()
		if strings.HasPrefix(line, "#") && !strings.HasPrefix(line, "#HttpOnly_") {
			continue
		}
		if strings.TrimSpace(line) == "" {
			continue
		}
		parts := strings.Split(line, "\t")
		if len(parts) < 7 {
			continue
		}

		domain := parts[0]
		httpOnly := false
		if strings.HasPrefix(domain, "#HttpOnly_") {
			httpOnly = true
			domain = strings.TrimPrefix(domain, "#HttpOnly_")
		}
		// parts[1] is include_subdomains (not directly used in http.Cookie)
		path := parts[2]
		secure := parts[3] == "TRUE"
		expires, _ := strconv.ParseInt(parts[4], 10, 64)
		name := parts[5]
		value := parts[6]

		cookies = append(cookies, &http.Cookie{
			Name:     name,
			Value:    value,
			Path:     path,
			Domain:   domain,
			Expires:  time.Unix(expires, 0),
			Secure:   secure,
			HttpOnly: httpOnly,
		})
	}

	return cookies, scanner.Err()
}

// SetCookiesFromSlice sets cookies on the jar for a given URL.
func (j *Jar) SetCookiesFromSlice(u *url.URL, cookies []*http.Cookie) {
	j.Jar.SetCookies(u, cookies)
}

// Update reads the existing cookies from the file, removes expired ones,
// updates with the new cookies (replacing conflicts), and saves the result.
// The domain parameter is used as a fallback for cookies without a domain set.
func (j *Jar) Update(filename string, newCookies []*http.Cookie, domain string) error {
	// Try to load existing cookies
	existing, err := Load(filename)
	if err != nil && !os.IsNotExist(err) {
		// If file exists but error (e.g. permission), returns error
		return err
	}

	// Filter expired and prepare map for merging
	cookieMap := make(map[string]*http.Cookie)
	now := time.Now()

	// Helper to generate key
	getKey := func(c *http.Cookie) string {
		return c.Domain + "\t" + c.Path + "\t" + c.Name
	}

	// Add existing non-expired cookies
	for _, c := range existing {
		if c.Expires.After(now) || c.Expires.IsZero() {
			cookieMap[getKey(c)] = c
		}
	}

	// Add/Overwrite with new cookies
	for _, c := range newCookies {
		cookieMap[getKey(c)] = c
	}

	// Flatten back to slice
	var finalCookies []*http.Cookie
	for _, c := range cookieMap {
		finalCookies = append(finalCookies, c)
	}

	return j.Save(filename, finalCookies, domain)
}

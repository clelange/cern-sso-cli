package cookie

import (
	"bufio"
	"fmt"
	"net/http"
	"net/http/cookiejar"
	"net/url"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"golang.org/x/net/publicsuffix"
)

// Jar wraps http.CookieJar with persistence to Netscape format.
type Jar struct {
	*cookiejar.Jar
}

// NewJar creates a new cookie jar.
func NewJar() (*Jar, error) {
	jar, err := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List})
	if err != nil {
		return nil, err
	}
	return &Jar{Jar: jar}, nil
}

// Save writes cookies to a file in Netscape format.
func (j *Jar) Save(filename string, cookies []*http.Cookie, domain string) error {
	dir := filepath.Dir(filename)
	if dir != "" {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}

	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()

	// Netscape cookie file header
	fmt.Fprintln(f, "# Netscape HTTP Cookie File")
	fmt.Fprintln(f, "# https://curl.se/docs/http-cookies.html")
	fmt.Fprintln(f, "# This file was generated by cern-sso-cli. Edit at your own risk.")
	fmt.Fprintln(f, "")

	for _, c := range cookies {
		httpOnly := "FALSE"
		if c.HttpOnly {
			httpOnly = "TRUE"
		}
		secure := "FALSE"
		if c.Secure {
			secure = "TRUE"
		}
		expires := c.Expires.Unix()
		if expires <= 0 {
			// Default to 10 hours from now if no expiry (CERN SSO cookie validity)
			expires = time.Now().Add(10 * time.Hour).Unix()
		}
		domainField := c.Domain
		if domainField == "" {
			domainField = domain
		}
		includeSubdomains := "FALSE"
		if strings.HasPrefix(domainField, ".") {
			includeSubdomains = "TRUE"
		}
		path := c.Path
		if path == "" {
			path = "/"
		}
		// Format: domain \t include_subdomains \t path \t secure \t expires \t name \t value
		// Note: httpOnly is encoded as #HttpOnly_ prefix on domain
		domainOutput := domainField
		if c.HttpOnly {
			domainOutput = "#HttpOnly_" + domainField
			httpOnly = "TRUE" // Not used in standard format, but we use prefix
		}
		_ = httpOnly // silence unused warning; httpOnly is encoded in domain prefix
		fmt.Fprintf(f, "%s\t%s\t%s\t%s\t%d\t%s\t%s\n",
			domainOutput, includeSubdomains, path, secure, expires, c.Name, c.Value)
	}

	return nil
}

// Load reads cookies from a Netscape format file.
func Load(filename string) ([]*http.Cookie, error) {
	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	var cookies []*http.Cookie
	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := scanner.Text()
		if strings.HasPrefix(line, "#") && !strings.HasPrefix(line, "#HttpOnly_") {
			continue
		}
		if strings.TrimSpace(line) == "" {
			continue
		}
		parts := strings.Split(line, "\t")
		if len(parts) < 7 {
			continue
		}

		domain := parts[0]
		httpOnly := false
		if strings.HasPrefix(domain, "#HttpOnly_") {
			httpOnly = true
			domain = strings.TrimPrefix(domain, "#HttpOnly_")
		}
		// parts[1] is include_subdomains (not directly used in http.Cookie)
		path := parts[2]
		secure := parts[3] == "TRUE"
		expires, _ := strconv.ParseInt(parts[4], 10, 64)
		name := parts[5]
		value := parts[6]

		cookies = append(cookies, &http.Cookie{
			Name:     name,
			Value:    value,
			Path:     path,
			Domain:   domain,
			Expires:  time.Unix(expires, 0),
			Secure:   secure,
			HttpOnly: httpOnly,
		})
	}

	return cookies, scanner.Err()
}

// SetCookiesFromSlice sets cookies on the jar for a given URL.
func (j *Jar) SetCookiesFromSlice(u *url.URL, cookies []*http.Cookie) {
	j.Jar.SetCookies(u, cookies)
}

// Update reads the existing cookies from the file, removes expired ones,
// updates with the new cookies (replacing conflicts), and saves the result.
// The domain parameter is used as a fallback for cookies without a domain set.
func (j *Jar) Update(filename string, newCookies []*http.Cookie, domain string) error {
	// Try to load existing cookies
	existing, err := Load(filename)
	if err != nil && !os.IsNotExist(err) {
		// If file exists but error (e.g. permission), returns error
		return err
	}

	// Filter expired and prepare map for merging
	cookieMap := make(map[string]*http.Cookie)
	now := time.Now()

	// Helper to generate key
	getKey := func(c *http.Cookie) string {
		return c.Domain + "\t" + c.Path + "\t" + c.Name
	}

	// Add existing non-expired cookies
	for _, c := range existing {
		if c.Expires.After(now) || c.Expires.IsZero() {
			cookieMap[getKey(c)] = c
		} else {
			fmt.Printf("Removing expired cookie: %s (expired %s)\n", c.Name, c.Expires)
		}
	}

	// Add/Overwrite with new cookies
	for _, c := range newCookies {
		cookieMap[getKey(c)] = c
	}

	// Flatten back to slice
	var finalCookies []*http.Cookie
	for _, c := range cookieMap {
		finalCookies = append(finalCookies, c)
	}

	return j.Save(filename, finalCookies, domain)
}
